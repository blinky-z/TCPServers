# TCP Серверы

## Вступление
Различные имплементации blocking и non-blocking I/O TCP серверов

## Полезные bash команды для дебага сервера

1) #### ```ps aux | fgrep <pattern>```
Данная команда ищет все процессы по указанному паттерну. Полезна при необходимости узнать id процесса сервера

Пример использования:
Скомпилируем наш исходный файл с сервером и запустим его
```bash
g++ StartNonBlockingServer.cpp -O2 -o StartServer
./StartServer
```

Найдем id процесса сервера:
```bash
ps aux | fgrep StartServer
```

Output:
```
root    12608  0.0  0.0  13996  1832 pts/1    S+   23:45   0:00 ./StartServer
root    12610  0.0  0.0  21536  1000 pts/0    S+   23:45   0:00 grep -F --color=auto StartServer
```

Нас интересует первая строчка, откуда мы узнаем процесс нашего сервера - *12608*. Он понадобится нам далее

---

2) ####  ```lsof -p <process_id>```
Данная команда выводит список всех открытых процессом файлов. В случае сервера это позволит нам увидеть открытые файловые
дескрипторы сокетов.

Пример использования:

```lsof -p 12608```

Output:
```
COMMAND     PID  USER   FD   TYPE   DEVICE SIZE/OFF    NODE NAME
StartServ 12608 root  cwd    DIR    259,6     4096  927591 /home/root/CLionProjects/SocketLearn
StartServ 12608 root  rtd    DIR    259,6     4096       2 /
StartServ 12608 root  txt    REG    259,6    19416  925481 /home/root/CLionProjects/SocketLearn/StartServer
StartServ 12608 root  mem    REG    259,6  1700792  136859 /lib/x86_64-linux-gnu/libm-2.27.so
StartServ 12608 root  mem    REG    259,6  2030544  136796 /lib/x86_64-linux-gnu/libc-2.27.so
StartServ 12608 root  mem    REG    259,6    96616  131157 /lib/x86_64-linux-gnu/libgcc_s.so.1
StartServ 12608 root  mem    REG    259,6  1594832 1179779 /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.25
StartServ 12608 root  mem    REG    259,6   170960  136768 /lib/x86_64-linux-gnu/ld-2.27.so
StartServ 12608 root    0u   CHR    136,1      0t0       4 /dev/pts/1
StartServ 12608 root    1u   CHR    136,1      0t0       4 /dev/pts/1
StartServ 12608 root    2u   CHR    136,1      0t0       4 /dev/pts/1
StartServ 12608 root    3u  IPv4 77107935      0t0     TCP *:http-alt (LISTEN) <- Наш открытый fd мастер сокета
```

---

3) #### ```sudo strace -p <process_id>```
Данная команда позволяет отслеживать все системные вызовы процесса
Это позволит нам наблюдать за тем, что происходит внутри системы и какие происходят системные вызовы к ядру.

Рассмотрим несколько примеров (на примере *select* сервера):

  * Принятие нового соединения:
```
accept(3, NULL, NULL)                   = 4
fcntl(4, F_GETFL)                       = 0x2 (flags O_RDWR)
fcntl(4, F_SETFL, O_RDWR|O_NONBLOCK)    = 0
select(5, [3 4], NULL, NULL, NULL
```

Мы видим, что новое соединение было принято и сервер снова повис на select в бесконечном таймауте, ожидая новых ивентов

  * Принятие сообщения от клиента:
```
recvfrom(4, "Hello, Select Server!\r\n", 1023, MSG_NOSIGNAL, NULL, NULL) = 23
sendto(4, "Hello, Select Server!\r\n", 23, MSG_NOSIGNAL, NULL, 0) = 23
select(5, [3 4], NULL, NULL, NULL
```

Мы видим системные вызовы recvfrom и sendto на файловом дескрипторе с номером **4**, где было принято сообщение размером 23 и отображено такое же, далее сервер снова повис
в таймауте

  * Отключение клиента от сервера:
```
recvfrom(4, "", 1023, MSG_NOSIGNAL, NULL, NULL) = 0
shutdown(4, SHUT_RDWR)                  = 0
close(4)                                = 0
```

Мы видим, что на сервер пришло пустое сообщение, а значит клиент отключился, соответственно мы на стороне сервера закрываем данный сокет, что и видно по системным вызовам

## Асинхронная работа с сетью
**Ассинхронный I/O** - это вид неблокирующего I/O, который позволяет продолжать работу, не дожидаясь окончания передачи данных.
Данный вид сетевого программирования возник потому, что передача данных намного медленнее, чем их обработка. Поэтому, чтобы использовать время максимально эффективно и не давать
серверу простаивать в бездействии, требуется асинхронный I/O.

## Библиотеки, предоставляющие возможности асинхронной работы с сетью

### Библиотека Libevent

#### Установка библиотеки:

**bash:**
```bash
sudo apt-get install libevent-dev
```

#### Принцицы работы библиотеки
Основные модули библиотеки - это *event* и *event_base*. Они представляют абстрактный API для различных функций управления неблокирующим I/O.
Работа программы основана на событиях (event'ы). Для каждого события создается *callback функция*, которая обрабатывает произошедшее событие.
Каждому event_base соответствует свой пул ивентов. *Event* - это главный объект всех операций в библиотеке libevent.

Разработчик может указать один из поддерживаемых библиотекой механизмов: *select*, *poll*, *epoll*, *kqueue*, *devpoll*, *evport*, *win32*.
При этом разработчику не потребуется прямое взаимодействие с API данных механизмов, так как библиотека оборачивает их, предоставляя разработчику единый API для управления
неблокирующим I/O.

Особенность обертки подходящих различных механизмов работы с сетью в зависимости от платформы обеспечивает переносимость и удобство использования на различных платформах.

---

#### Пример echo сервера

Пример echo сервера, использующего библиотеку *libevent*, показан в файле [EchoLibeventServer.cpp](https://github.com/blinky-z/TCPServers/blob/master/EchoLibeventServer.cpp)

**Запуск сервера:**

1) **Скомпилируйте сервер** :

```bash
g++ EchoLibeventServer.cpp -levent -o EchoServer
```

2) **Запустите его, передав следующие аргументы:**
    1) Порт
    2) Требуемый тип механизма работы с сетью:
        * select
        * poll
        * epoll

```bash
./EchoServer 8080 select // или poll, epoll
```

---

### Библиотека Libev

Данная библиотека проще, быстрее и содержит меньше legacy кода по сравнению с **Libevent**.

#### Установка библиотеки

**bash:**
```bash
sudo apt-get install libev-dev
```

#### Принцицы работы библиотеки

Данная библиотека обладает похожим на Libevent дизайном, однако существуют отличия. Основные модули библиотеки - это *loop* и *watcher*. Существует два типа лупов - один
*стандартный (default loop)* и *остальные, дополнительные*. Также как и в libevent, Каждому лупу соответствует свой пул вотчеров, а каждому вотчеру своя callback функция.
Библиотека libev обертывает код библиотеки *libevent*, предоставляя то же управление буферами, DNS, HTTP модулями, что и libevent.

Библиотека поддерживает такие механизмы работы с сетью, как *select*, *poll*, *epoll*.
Разработчику не потребуется прямое взаимодействие с API данных механизмов, так как библиотека оборачивает их, предоставляя разработчику единый API для управления
неблокирующим I/O.

Особенность обертки подходящих различных механизмов работы с сетью в зависимости от платформы обеспечивает переносимость и удобство использования на различных платформах.

---

#### Пример echo сервера

Пример echo сервера, использующего библиотеку *libev*, показан в файле [EchoLibevServer.cpp](https://github.com/blinky-z/TCPServers/blob/master/EchoLibevServer.cpp)

**Запуск сервера:**

1) **Скомпилируйте сервер** :

```bash
g++ EchoLibevServer.cpp -lev -o EchoServer
```

2) **Запустите его, передав следующие аргументы:**
    1) Порт
    2) Требуемый тип механизма работы с сетью:
        * select
        * poll
        * epoll

```bash
./EchoServer 8080 select // или poll, epoll
```